import { debug } from "@actions/core";
import { Context } from "@actions/github/lib/context";
import type { GitHub } from "@actions/github/lib/utils";
import { config, cosmic } from "@anandchowdhary/cosmic";
import slugify from "@sindresorhus/slugify";
import { getByTag } from "locale-codes";
import { search, SearchOptions } from "../google-books";
import { updateSummary } from "./update-summary";

const clean = (str: string) => slugify(str, { lowercase: true, separator: " " });

export const onNewIssue = async (
  owner: string,
  repo: string,
  context: Context,
  octokit: InstanceType<typeof GitHub>
) => {
  debug("Started onNewIssue");
  try {
    await cosmic("bookshelf");
    debug("Got config object");
  } catch (error) {}
  const issue = await octokit.rest.issues.get({
    owner: context.issue.owner,
    repo: context.issue.repo,
    issue_number: context.issue.number,
  });
  debug(`Got issue #${issue.data.number}`);
  if (config("users") && Array.isArray(config("users"))) {
    if (!(config("users") as string[]).find((i) => i === (issue.data.user || {}).login))
      return debug("User not allowed, skipping");
  }
  let body =
    "<!-- This comment is autogenerated by bookshelf-action <https://github.com/AnandChowdhary/bookshelf-action> -->\n\n";
  const labels: string[] = [
    "kind: book",
    `started: ${clean(new Date().toLocaleString("en", { month: "long" }))}`,
    `started: ${new Date().getUTCFullYear()}`,
  ];
  try {
    const issueTitle = issue.data.title.trim();
    debug(`Searching for "${issueTitle}"`);
    
    // Configuration for book search - can be customized based on your needs
    const searchOptions: SearchOptions = {
      maxResults: 15,       // Get more results for better selection
      language: 'en',       // Default to English books (can be made configurable)
      minRating: 0          // Don't filter by rating yet
    };
    
    // Try to extract ISBN if present in the issue body
    let details;
    const isbnMatch = issue.data.body ? issue.data.body.match(/ISBN[-]?1[03]?:?\s?([0-9-]+)/i) : null;
    
    if (isbnMatch && isbnMatch[1]) {
      // If ISBN found in issue body, use it for precise search
      try {
        debug(`ISBN found in issue body: ${isbnMatch[1]}, searching by ISBN`);
        const isbnSearch = await import('../google-books');
        details = await isbnSearch.searchByIsbn(isbnMatch[1]);
      } catch (isbnError) {
        debug(`ISBN search failed: ${String(isbnError)}, falling back to title search`);
        details = await search(issueTitle, searchOptions);
      }
    } else {
      // Otherwise search by title
      details = await search(issueTitle, searchOptions);
    }
    
    body += `Congrats on adding **${details.title}** by ${details.authors.join(
      ", "
    )} to your bookshelf, I hope you enjoy it! It has an average of ${
      details.averageRating || "unknown"
    }/5 stars and ${(details.ratingsCount || 0).toLocaleString()} ratings on [Google Books](${
      details.googleBooks.info
    }).\n\n<details>
 <summary>Book details (JSON)</summary>

\`\`\`json
${JSON.stringify(details, null, 2)}
\`\`\`

</details>`;
    details.authors.forEach((i) => labels.push(`author: ${clean(i)}`));
    details.categories.forEach((i) => labels.push(`category: ${clean(i)}`));
    if (details.publishedDate) {
      const publishDate = new Date(details.publishedDate);
      labels.push(`year: ${publishDate.getUTCFullYear()}`);
      labels.push(`decade: ${Math.floor(publishDate.getUTCFullYear() / 10) * 10}s`);
    }
    if (details.language)
      labels.push(`language: ${clean(getByTag(details.language).name || details.language)}`);
    if (details.publisher) labels.push(`publisher: ${clean(details.publisher)}`);
    debug("Added labels from search results");
  } catch (error) {
    console.log(error);
    debug(`Got an error in search results: ${String(error)}`);
    body +=
      "I couldn't find details about this book using the Google Books API. Don't worry, you can still track it.\n\n";
  }
  body += `When you're finished with reading this book, just close this issue and I'll mark it as completed. Best of luck! 👍`;
  await octokit.rest.issues.createComment({
    owner: context.issue.owner,
    repo: context.issue.repo,
    issue_number: context.issue.number,
    body,
  });
  debug("Added comment to issue");
  await octokit.rest.issues.addLabels({
    owner: context.issue.owner,
    repo: context.issue.repo,
    issue_number: context.issue.number,
    labels: labels.map((label) => (label.length > 50 ? `${label.substring(0, 47)}...` : label)),
  });
  debug("Added all labels to issue");
  await octokit.rest.issues.lock({
    owner: context.issue.owner,
    repo: context.issue.repo,
    issue_number: context.issue.number,
  });
  debug("Locked issue");
  await updateSummary(owner, repo, context, octokit);
};
